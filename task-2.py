# Завдання 2

# Реалізуйте двійковий пошук для відсортованого масиву з дробовими числами.
# Написана функція для двійкового пошуку повинна повертати кортеж, де
# - Першим елементом є кількість ітерацій, потрібних для знаходження елемента.
# - Другим елементом має бути "верхня межа" — це найменший елемент, який є більшим або рівним заданому значенню.

from typing import List, Tuple, Optional

from typing import List, Tuple, Optional

def binary_search_with_upper_bound(arr: List[float], target: float) -> Tuple[int, Optional[float]]:
    """
    Виконує двійковий пошук у відсортованому масиві з дробовими числами.
    
    Параметри:
    arr : List[float] - відсортований масив дробових чисел.
    target : float - значення, яке шукається в масиві.
    
    Повертає:
    Tuple[int, Optional[float]] - кортеж, де:
        - перший елемент — кількість ітерацій для знаходження елемента або верхньої межі;
        - другий елемент — найменший елемент масиву, що більший або рівний заданому значенню (upper_bound),
          або None, якщо такого елемента немає.
    """
    
    # Ініціалізація початкових індексів та змінних
    left, right = 0, len(arr) - 1  # початок і кінець пошукового діапазону
    iterations = 0                 # лічильник ітерацій
    upper_bound = None             # змінна для збереження верхньої межі
    
    # Основний цикл двійкового пошуку
    while left <= right:
        iterations += 1            # збільшуємо кількість ітерацій
        mid = (left + right) // 2  # обчислюємо середній індекс
        mid_val = arr[mid]         # значення елемента в середині масиву
        
        # Якщо середній елемент дорівнює шуканому значенню, повертаємо результат
        if mid_val == target:
            return (iterations, mid_val)
        # Якщо середній елемент менший за шукане значення, зміщуємо ліву межу праворуч
        elif mid_val < target:
            left = mid + 1
        # Якщо середній елемент більший за шукане значення, оновлюємо верхню межу
        # і зміщуємо праву межу ліворуч
        else:
            upper_bound = mid_val
            right = mid - 1

    # Повертаємо кількість ітерацій і верхню межу (або None, якщо не знайдено)
    return (iterations, upper_bound)

# Повторний тест функції, щоб переконатися, що вона не змінила поведінку
sample_array = [1.2, 3.5, 5.1, 7.8, 10.5, 15.3]
target_value = 6.0

print(binary_search_with_upper_bound(sample_array, target_value))